import os
import cv2
import json
import random
import copy
import numpy as np

IMG_DIR = "images"
ANN_DIR = "annotations"
OUT_IMG = "aug_separate_final"
OUT_ANN = "aug_separate_final_ann"

os.makedirs(OUT_IMG, exist_ok=True)
os.makedirs(OUT_ANN, exist_ok=True)

MAX_SWAPS = 5
NUM_IMAGES_PER_ORIG = 400
SIZE_TOL = 5

def is_free(new_box, placed_boxes):
    nx1, ny1, nx2, ny2 = new_box
    for b in placed_boxes:
        x1, y1, x2, y2 = b
        if not (nx2 <= x1 or nx1 >= x2 or ny2 <= y1 or ny1 >= y2):
            return False
    return True

def load_image_and_plots(img_path, ann_path):
    img = cv2.imread(img_path)
    if img is None:
        raise RuntimeError(f"Erreur: impossible de charger {img_path}")
    with open(ann_path) as f:
        ann = json.load(f)
    plots = []
    for s in ann["shapes"]:
        if s.get("label") != "plot":
            continue
        pts = s["points"]
        x1, y1 = int(min(p[0] for p in pts)), int(min(p[1] for p in pts))
        x2, y2 = int(max(p[0] for p in pts)), int(max(p[1] for p in pts))
        crop = img[y1:y2, x1:x2]
        ph, pw, _ = crop.shape
        plots.append({"crop": crop, "pos": (x1, y1), "size": (pw, ph)})
    if len(plots) == 0:
        raise RuntimeError(f"Erreur: aucun plot trouvé pour {img_path}")
    return img, plots

def augment_brightness_contrast(img):
    # Facteur de contraste entre 0.8 et 1.2
    alpha = random.uniform(0.8, 1.2)
    # Décalage de brillance entre -30 et 30
    beta = random.randint(-30, 30)
    img_aug = cv2.convertScaleAbs(img, alpha=alpha, beta=beta)
    return img_aug

def generate_images(img, plots, num_images, idx_start=0):
    H, W, _ = img.shape
    idx = idx_start
    for _ in range(num_images):
        canvas = img.copy()
        plots_copy = copy.deepcopy(plots)

        # Swaps aléatoires
        n_swaps = min(MAX_SWAPS, len(plots_copy)//2)
        for _ in range(n_swaps):
            a, b = random.sample(range(len(plots_copy)), 2)
            pw_a, ph_a = plots_copy[a]["size"]
            pw_b, ph_b = plots_copy[b]["size"]
            if abs(pw_a - pw_b) <= SIZE_TOL and abs(ph_a - ph_b) <= SIZE_TOL:
                pos_a, pos_b = plots_copy[a]["pos"], plots_copy[b]["pos"]
                plots_copy[a]["pos"], plots_copy[b]["pos"] = pos_b, pos_a

        # Supprimer aléatoirement 0 à 2 plots et mettre noir
        num_remove = random.randint(0, 2)
        remove_indices = random.sample(range(len(plots_copy)), num_remove)

        placed_boxes = []
        shapes = []

        for i, p in enumerate(plots_copy):
            x, y = p["pos"]
            pw, ph = p["size"]
            new_box = (x, y, x+pw, y+ph)

            # Supprimer le plot si choisi
            if i in remove_indices:
                canvas[y:y+ph, x:x+pw] = 0  # noir
                continue

            if x+pw > W or y+ph > H or not is_free(new_box, placed_boxes):
                canvas[y:y+ph, x:x+pw] = img[y:y+ph, x:x+pw]
                continue

            canvas[y:y+ph, x:x+pw] = p["crop"]
            placed_boxes.append(new_box)
            shapes.append({"label":"plot","points":[[x, y],[x+pw, y+ph]],"shape_type":"rectangle"})

        # ---------------------------
        # Data augmentation contraste/brillance
        canvas = augment_brightness_contrast(canvas)

        img_name = f"separate_{idx}.png"
        json_name = f"separate_{idx}.json"
        cv2.imwrite(os.path.join(OUT_IMG, img_name), canvas)
        ann_out = {"version":"5.0.1","imagePath":img_name,"imageHeight":H,"imageWidth":W,"shapes":shapes}
        with open(os.path.join(OUT_ANN, json_name), "w") as f:
            json.dump(ann_out, f, indent=2)
        idx += 1
    return idx

# --- Image 1 ---
img_files = sorted([f for f in os.listdir(IMG_DIR) if f.lower().endswith((".jpg",".png"))])
if len(img_files) < 2:
    raise RuntimeError("Erreur: il faut au moins 2 images dans le dossier.")

img1_path = os.path.join(IMG_DIR, img_files[0])
ann1_path = os.path.join(ANN_DIR, img_files[0].replace(".jpg",".json").replace(".png",".json"))
img1, plots1 = load_image_and_plots(img1_path, ann1_path)
idx = generate_images(img1, plots1, NUM_IMAGES_PER_ORIG, idx_start=0)

# --- Image 2 ---
img2_path = os.path.join(IMG_DIR, img_files[1])
ann2_path = os.path.join(ANN_DIR, img_files[1].replace(".jpg",".json").replace(".png",".json"))
img2, plots2 = load_image_and_plots(img2_path, ann2_path)
idx = generate_images(img2, plots2, NUM_IMAGES_PER_ORIG, idx_start=idx)

print(f"Génération terminée : {idx} images créées avec plots noirs et contraste/brillance aléatoire.")



##############
import os
import cv2
import json
import random
import numpy as np
import matplotlib.pyplot as plt

# ------------------------------
# Paramètres
# ------------------------------
SRC_IMG_DIR = "aug_separate_final"
SRC_ANN_DIR = "aug_separate_final_ann"
YOLO_DIR = "yolo_dataset"
NEW_HEIGHT = 640  # redimensionner hauteur
CLASS_NAMES = ["plot"]
YAML_FILE = os.path.join(YOLO_DIR, "dataset.yaml")

os.makedirs(YOLO_DIR, exist_ok=True)
for split in ["train","val","test"]:
    os.makedirs(os.path.join(YOLO_DIR, split, "images"), exist_ok=True)
    os.makedirs(os.path.join(YOLO_DIR, split, "labels"), exist_ok=True)

# ------------------------------
# Récupérer images et shuffle
# ------------------------------
img_files = [f for f in os.listdir(SRC_IMG_DIR) if f.lower().endswith((".png",".jpg"))]
random.shuffle(img_files)
n_total = len(img_files)
n_train = int(n_total*0.8)
n_val = int(n_total*0.1)
splits_files = {
    "train": img_files[:n_train],
    "val": img_files[n_train:n_train+n_val],
    "test": img_files[n_train+n_val:]
}

# ------------------------------
# Conversion bbox JSON -> YOLO
# ------------------------------
def convert_bbox_yolo(bbox, orig_size, new_size):
    """bbox = [x1,y1,x2,y2], new_size=(new_h, new_w)"""
    orig_h, orig_w = orig_size
    new_h, new_w = new_size
    x1, y1, x2, y2 = bbox
    # redimension
    x1_new = x1
    x2_new = x2
    y1_new = y1 * (new_h/orig_h)
    y2_new = y2 * (new_h/orig_h)
    xc = (x1_new + x2_new)/2 / new_w
    yc = (y1_new + y2_new)/2 / new_h
    w = (x2_new - x1_new)/new_w
    h = (y2_new - y1_new)/new_h
    return [xc, yc, w, h]

# ------------------------------
# Traitement images et labels
# ------------------------------
for split, files in splits_files.items():
    for f in files:
        img_path = os.path.join(SRC_IMG_DIR, f)
        ann_path = os.path.join(SRC_ANN_DIR, f.replace(".png",".json").replace(".jpg",".json"))
        if not os.path.exists(ann_path):
            print(f"Erreur: annotation manquante pour {f}")
            continue

        img = cv2.imread(img_path)
        H, W, _ = img.shape
        new_h = NEW_HEIGHT
        new_w = W
        img_resized = cv2.resize(img, (new_w, new_h))

        # Sauvegarder l'image
        cv2.imwrite(os.path.join(YOLO_DIR, split, "images", f), img_resized)

        # Lire annotation JSON
        with open(ann_path) as af:
            ann = json.load(af)
        yolo_lines = []
        for shape in ann["shapes"]:
            if shape["label"] not in CLASS_NAMES:
                continue
            x1, y1 = shape["points"][0]
            x2, y2 = shape["points"][1]
            bbox = convert_bbox_yolo([x1,y1,x2,y2], (H,W), (new_h,new_w))
            cls_idx = CLASS_NAMES.index(shape["label"])
            yolo_lines.append(f"{cls_idx} {' '.join([str(round(v,6)) for v in bbox])}")

        # Sauvegarder annotation YOLO
        lbl_file = os.path.join(YOLO_DIR, split, "labels", f.replace(".png",".txt").replace(".jpg",".txt"))
        with open(lbl_file, "w") as lf:
            lf.write("\n".join(yolo_lines))

print("Conversion YOLO terminée avec hauteur redimensionnée et largeur conservée !")

# ------------------------------
# Génération fichier YAML avec chemins absolus
# ------------------------------
yaml_content = f"""
path: {os.path.abspath(YOLO_DIR)}
train: {os.path.abspath(os.path.join(YOLO_DIR, 'train', 'images'))}
val: {os.path.abspath(os.path.join(YOLO_DIR, 'val', 'images'))}
test: {os.path.abspath(os.path.join(YOLO_DIR, 'test', 'images'))}
nc: {len(CLASS_NAMES)}
names: {CLASS_NAMES}
"""

with open(YAML_FILE, "w") as f:
    f.write(yaml_content.strip())

print(f"Fichier YAML généré : {YAML_FILE}")

# ------------------------------
# Affichage de 10 images pour vérification
# ------------------------------
def display_yolo_image(img_path, lbl_path):
    img = cv2.imread(img_path)
    img_disp = img.copy()
    H, W, _ = img.shape
    with open(lbl_path) as f:
        lines = f.readlines()
    for l in lines:
        cls, xc, yc, w, h = [float(v) for v in l.strip().split()]
        x1 = int((xc - w/2)*W)
        y1 = int((yc - h/2)*H)
        x2 = int((xc + w/2)*W)
        y2 = int((yc + h/2)*H)
        cv2.rectangle(img_disp, (x1,y1),(x2,y2),(0,255,0),2)
        cv2.putText(img_disp, CLASS_NAMES[int(cls)], (x1, y1-5),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0,255,0),1)
    return img_disp

sample_imgs = random.sample(os.listdir(os.path.join(YOLO_DIR,"train","images")), min(10,len(os.listdir(os.path.join(YOLO_DIR,"train","images")))))
plt.figure(figsize=(15,10))
for i, img_file in enumerate(sample_imgs):
    img_path = os.path.join(YOLO_DIR,"train","images",img_file)
    lbl_path = os.path.join(YOLO_DIR,"train","labels",img_file.replace(".png",".txt").replace(".jpg",".txt"))
    img_disp = display_yolo_image(img_path, lbl_path)
    plt.subplot(2,5,i+1)
    plt.imshow(cv2.cvtColor(img_disp, cv2.COLOR_BGR2RGB))
    plt.axis("off")
plt.show()
