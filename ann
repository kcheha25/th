import os
import cv2
import json
import random
import copy

# ------------------------------
# Dossiers
# ------------------------------
IMG_DIR = "images"
ANN_DIR = "annotations"

PAD_IMG = "images_padded"
PAD_ANN = "annotations_padded"

OUT_IMG = "aug_separate_500"
OUT_ANN = "aug_separate_500_ann"

os.makedirs(PAD_IMG, exist_ok=True)
os.makedirs(PAD_ANN, exist_ok=True)
os.makedirs(OUT_IMG, exist_ok=True)
os.makedirs(OUT_ANN, exist_ok=True)

# ------------------------------
# Paramètres
# ------------------------------
MIN_PLOTS = 5
MAX_PLOTS = 20
MAX_SWAPS = 5
NUM_IMAGES_PER_ORIG = 500

# ------------------------------
# 1️⃣ Padding uniforme
# ------------------------------
max_h = 0
img_files = [f for f in os.listdir(IMG_DIR) if f.lower().endswith((".jpg",".png"))]

for f in img_files:
    img_path = os.path.join(IMG_DIR, f)
    img = cv2.imread(img_path)
    if img is None:
        print(f"Erreur: impossible de charger l'image {img_path}")
        continue
    h, w, _ = img.shape
    max_h = max(max_h, h)

for f in img_files:
    img_path = os.path.join(IMG_DIR, f)
    json_path = os.path.join(ANN_DIR, f.replace(".jpg",".json").replace(".png",".json"))
    if not os.path.exists(json_path):
        print(f"Erreur: annotation manquante pour {img_path}")
        continue
    img = cv2.imread(img_path)
    if img is None:
        print(f"Erreur: impossible de charger l'image {img_path} après vérification")
        continue
    h, w, _ = img.shape
    pad = max_h - h
    padded = cv2.copyMakeBorder(img, 0, pad, 0, 0, cv2.BORDER_CONSTANT, value=(0,0,0))
    cv2.imwrite(os.path.join(PAD_IMG, f), padded)
    with open(json_path) as jf:
        ann = json.load(jf)
    ann["imageHeight"] = max_h
    ann["imageWidth"] = w
    with open(os.path.join(PAD_ANN, os.path.basename(json_path)), "w") as jf:
        json.dump(ann, jf, indent=2)

# ------------------------------
# 2️⃣ Charger images et plots
# ------------------------------
dataset = []
for jf in sorted(os.listdir(PAD_ANN)):
    if not jf.endswith(".json"): 
        continue
    with open(os.path.join(PAD_ANN, jf)) as f:
        ann = json.load(f)
    img_path = os.path.join(PAD_IMG, ann["imagePath"])
    img = cv2.imread(img_path)
    if img is None:
        print(f"Erreur: impossible de charger l'image padding {img_path}")
        continue
    plots = []
    for s in ann["shapes"]:
        if s.get("label") != "plot": 
            continue
        pts = s["points"]
        x1, y1 = int(min(p[0] for p in pts)), int(min(p[1] for p in pts))
        x2, y2 = int(max(p[0] for p in pts)), int(max(p[1] for p in pts))
        crop = img[y1:y2, x1:x2]
        ph, pw, _ = crop.shape
        plots.append({"crop": crop, "pos": (x1, y1), "size": (pw, ph)})
    if len(plots) == 0:
        print(f"Erreur: aucun plot trouvé pour {img_path}")
        continue
    dataset.append({"image": img, "plots": plots})

if len(dataset) < 2:
    raise RuntimeError("Erreur: moins de 2 images valides détectées après padding et vérification.")

# ------------------------------
# 3️⃣ Vérification chevauchement
# ------------------------------
def is_free(new_box, placed_boxes):
    nx1, ny1, nx2, ny2 = new_box
    for b in placed_boxes:
        x1, y1, x2, y2 = b
        if not (nx2 <= x1 or nx1 >= x2 or ny2 <= y1 or ny1 >= y2):
            return False
    return True

# ------------------------------
# 4️⃣ Génération images séparées
# ------------------------------
idx = 0

for i, data in enumerate(dataset):  # traitement séparé
    bg_image = data["image"]
    plots = data["plots"]
    H, W, _ = bg_image.shape

    for _ in range(NUM_IMAGES_PER_ORIG):
        canvas = bg_image.copy()
        n_plots = random.randint(MIN_PLOTS, min(MAX_PLOTS, len(plots)))
        selected = random.sample(plots, n_plots)
        plots_copy = copy.deepcopy(selected)

        # Swaps aléatoires
        n_swaps = min(MAX_SWAPS, len(plots_copy)//2)
        for _ in range(n_swaps):
            a, b = random.sample(range(len(plots_copy)), 2)
            pos_a, pos_b = plots_copy[a]["pos"], plots_copy[b]["pos"]
            plots_copy[a]["pos"], plots_copy[b]["pos"] = pos_b, pos_a

        placed_boxes = []
        shapes = []

        for p in plots_copy:
            x, y = p["pos"]
            pw, ph = p["size"]
            new_box = (x, y, x+pw, y+ph)
            if x+pw > W or y+ph > H or not is_free(new_box, placed_boxes):
                canvas[y:y+ph, x:x+pw] = bg_image[y:y+ph, x:x+pw]
                continue
            canvas[y:y+ph, x:x+pw] = p["crop"]
            placed_boxes.append(new_box)
            shapes.append({"label":"plot","points":[[x, y],[x+pw, y+ph]],"shape_type":"rectangle"})

        if len(shapes) >= MIN_PLOTS:
            img_name = f"separate_{idx}.png"
            json_name = f"separate_{idx}.json"
            cv2.imwrite(os.path.join(OUT_IMG, img_name), canvas)
            ann = {"version":"5.0.1","imagePath":img_name,"imageHeight":H,"imageWidth":W,"shapes":shapes}
            with open(os.path.join(OUT_ANN, json_name), "w") as f:
                json.dump(ann, f, indent=2)
            idx += 1

print(f"Génération terminée : {idx} images créées (500 par image).")
