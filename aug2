import pandas as pd

def save_selected_wavelengths(groups, class_names, class_spectra, save_path_10, save_path_20):
    
    results_10 = {}
    results_20 = {}
    
    for group in groups:
        sel_10 = select_mrmr_bands_for_group(class_spectra, group, n_features=10)
        sel_20 = select_mrmr_bands_for_group(class_spectra, group, n_features=20)
        
        for label in group:
            class_name = class_names[label]
            results_10[class_name] = sel_10
            results_20[class_name] = sel_20
    
    df10 = pd.DataFrame(dict([(k, pd.Series(v)) for k, v in results_10.items()]))
    df20 = pd.DataFrame(dict([(k, pd.Series(v)) for k, v in results_20.items()]))

    df10.to_excel(save_path_10, index=False)
    df20.to_excel(save_path_20, index=False)

    print("Fichiers Excel sauvegardés")


save_selected_wavelengths(
    groups,
    dataset.class_names,
    class_spectra,
    "wl_max10.xlsx",
    "wl_max20.xlsx"
)


def load_selected_wavelengths(path_excel):
    df = pd.read_excel(path_excel)
    selected = {}
    for col in df.columns:
        selected[col] = df[col].dropna().astype(int).tolist()
    return selected

wl_max10 = load_selected_wavelengths("wl_max10.xlsx")
wl_max20 = load_selected_wavelengths("wl_max20.xlsx")


import torch
import numpy as np
from spectral import envi
from pathlib import Path

def generate_augmented_cube(
    cube,
    class_name,
    netG,
    wl_max10,
    wl_max20,
    sam_threshold1=0.15,
    sam_threshold2=0.3,
    device="cuda"
):

    B, H, W = cube.shape
    augmented_cube = np.zeros_like(cube)

    selected_10 = wl_max10[class_name]
    selected_20 = wl_max20[class_name]

    for i in range(H):
        for j in range(W):
            real_spec = cube[:, i, j]

            if np.var(real_spec) < 1e-6:
                augmented_cube[:, i, j] = real_spec
                continue

            real_tensor = torch.tensor(2*real_spec-1, dtype=torch.float32).to(device)

            best_sam = 999
            best_fake = None

            for _ in range(5):
                noise = torch.randn_like(real_tensor)
                fake = netG(noise).detach().cpu().numpy()
                fake_denorm = (fake + 1) / 2
                sam = compute_sam(real_spec, fake_denorm)

                if sam < best_sam:
                    best_sam = sam
                    best_fake = fake_denorm

            if best_sam < sam_threshold1:
                new_spec = best_fake.copy()
                new_spec[selected_10] = real_spec[selected_10]

            elif best_sam < sam_threshold2:
                new_spec = best_fake.copy()
                new_spec[selected_20] = real_spec[selected_20]

            else:
                new_spec = real_spec  

            augmented_cube[:, i, j] = new_spec

    return augmented_cube


def generate_100_augmented_extrudes(
    input_cube_path,
    class_name,
    results_dir,
    wl_max10,
    wl_max20,
    output_dir,
    device="cuda"
):

    hdr = envi.open(input_cube_path)
    cube = np.array(hdr.load(), dtype=np.float32)

    netG = torch.load(f"./results/{class_name}/netG_best.pth")
    netG.to(device)
    netG.eval()

    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    for n in range(100):

        aug_cube = generate_augmented_cube(
            cube,
            class_name,
            netG,
            wl_max10,
            wl_max20,
            device=device
        )

        save_path = output_dir / f"{class_name}_aug_{n}.hdr"

        envi.save_image(
            str(save_path),
            aug_cube,
            dtype=np.float32,
            force=True,
            interleave="bsq"
        )

    print(f"100 extrudes générés pour {class_name}")


import matplotlib.pyplot as plt


def generate_augmented_cube(
    cube,
    class_name,
    netG,
    wl_max10,
    wl_max20,
    sam_threshold1=0.15,
    sam_threshold2=0.3,
    device="cuda",
    save_plots=False,
    plot_dir=None
):

    B, H, W = cube.shape
    augmented_cube = np.zeros_like(cube)

    selected_10 = wl_max10[class_name]
    selected_20 = wl_max20[class_name]

    if save_plots:
        plot_dir = Path(plot_dir)
        plot_dir.mkdir(parents=True, exist_ok=True)

    for i in range(H):
        for j in range(W):

            real_spec = cube[:, i, j]

            if np.var(real_spec) < 1e-6:
                augmented_cube[:, i, j] = real_spec
                continue

            real_tensor = torch.tensor(2*real_spec-1, dtype=torch.float32).to(device)

            best_sam = 999
            best_fake = None

            for _ in range(5):
                noise = torch.randn_like(real_tensor)
                fake = netG(noise).detach().cpu().numpy()
                fake_denorm = (fake + 1) / 2
                sam = compute_sam(real_spec, fake_denorm)

                if sam < best_sam:
                    best_sam = sam
                    best_fake = fake_denorm

            if best_sam < sam_threshold1:
                new_spec = best_fake.copy()
                new_spec[selected_10] = real_spec[selected_10]

            elif best_sam < sam_threshold2:
                new_spec = best_fake.copy()
                new_spec[selected_20] = real_spec[selected_20]

            else:
                new_spec = real_spec

            augmented_cube[:, i, j] = new_spec

            # -------- PLOT --------
            if save_plots:

                plt.figure(figsize=(8,5))
                plt.plot(real_spec, label="Real Spectrum", linewidth=2)
                plt.plot(best_fake, label="Best GAN Spectrum", linestyle="--")
                plt.plot(new_spec, label="Final Augmented Spectrum", linewidth=2)

                plt.title(f"{class_name} - Pixel ({i},{j}) - SAM={best_sam:.4f}")
                plt.xlabel("Band Index")
                plt.ylabel("Reflectance")
                plt.legend()
                plt.tight_layout()

                plt.savefig(plot_dir / f"{class_name}_{i}_{j}.png")
                plt.close()

    return augmented_cube

def generate_100_augmented_extrudes(
    input_cube_path,
    class_name,
    results_dir,
    wl_max10,
    wl_max20,
    output_dir,
    device="cuda"
):

    hdr = envi.open(input_cube_path)
    cube = np.array(hdr.load(), dtype=np.float32)

    netG = torch.load(f"./results/{class_name}/netG_best.pth")
    netG.to(device)
    netG.eval()

    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    for n in range(100):

        plot_folder = output_dir / f"plots_aug_{n}"

        aug_cube = generate_augmented_cube(
            cube,
            class_name,
            netG,
            wl_max10,
            wl_max20,
            device=device,
            save_plots=True,
            plot_dir=plot_folder
        )

        save_path = output_dir / f"{class_name}_aug_{n}.hdr"

        envi.save_image(
            str(save_path),
            aug_cube,
            dtype=np.float32,
            force=True,
            interleave="bsq"
        )

    print(f"100 extrudes générés pour {class_name}")



import matplotlib.pyplot as plt
from pathlib import Path
import torch
import numpy as np

def generate_augmented_cube(
    cube,
    class_name,
    netG,
    wl_max10,
    wl_max20,
    force_real_classes=None,
    sam_threshold1=0.15,
    sam_threshold2=0.3,
    device="cuda",
    save_plots=False,
    plot_dir=None
):

    if force_real_classes is None:
        force_real_classes = {}

    B, H, W = cube.shape
    augmented_cube = np.zeros_like(cube)

    selected_10 = wl_max10[class_name]
    selected_20 = wl_max20[class_name]

    full_range_27 = list(range(27))

    if save_plots:
        plot_dir = Path(plot_dir)
        plot_dir.mkdir(parents=True, exist_ok=True)

    plot_count = 0

    for i in range(H):
        for j in range(W):

            real_spec = cube[:, i, j]

            if np.var(real_spec) < 1e-6:
                augmented_cube[:, i, j] = real_spec
                continue

            if class_name in force_real_classes:
                augmented_cube[:, i, j] = real_spec
                continue

            real_tensor = torch.tensor(2*real_spec-1, dtype=torch.float32).to(device)
            real_tensor = real_tensor.unsqueeze(0).unsqueeze(0)

            best_sam = 999
            best_fake = None

            for _ in range(5):
                noise = torch.randn_like(real_tensor)
                fake = netG(noise).detach().cpu().squeeze().numpy()
                fake_denorm = (fake + 1) / 2
                sam = compute_sam(real_spec, fake_denorm)

                if sam < best_sam:
                    best_sam = sam
                    best_fake = fake_denorm

            if best_sam < sam_threshold1:

                if list(selected_10) == full_range_27:
                    new_spec = best_fake.copy()
                else:
                    new_spec = best_fake.copy()
                    new_spec[selected_10] = real_spec[selected_10]

            elif best_sam < sam_threshold2:

                if list(selected_20) == full_range_27:
                    new_spec = best_fake.copy()
                else:
                    new_spec = best_fake.copy()
                    new_spec[selected_20] = real_spec[selected_20]

            else:
                new_spec = real_spec

            augmented_cube[:, i, j] = new_spec

            if save_plots and plot_count < 10:

                plt.figure(figsize=(8,5))
                plt.plot(real_spec, label="Real Spectrum", linewidth=2)
                plt.plot(best_fake, label="Best GAN Spectrum", linestyle="--")
                plt.plot(new_spec, label="Final Augmented Spectrum", linewidth=2)

                plt.title(f"{class_name} - SAM={best_sam:.4f}")
                plt.xlabel("Band Index")
                plt.ylabel("Reflectance")
                plt.legend()
                plt.tight_layout()

                plt.savefig(plot_dir / f"{class_name}_{plot_count}.png")
                plt.close()

                plot_count += 1

    return augmented_cube


def generate_100_augmented_extrudes(
    input_cube_path,
    class_name,
    results_dir,
    wl_max10,
    wl_max20,
    output_dir,
    force_real_classes=None,
    device="cuda"
):

    hdr = envi.open(input_cube_path)
    cube = np.array(hdr.load(), dtype=np.float32)

    netG = torch.load(f"./results/{class_name}/netG_best.pth")
    netG.to(device)
    netG.eval()

    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    for n in range(100):

        plot_folder = output_dir / f"plots_aug_{n}"

        aug_cube = generate_augmented_cube(
            cube,
            class_name,
            netG,
            wl_max10,
            wl_max20,
            force_real_classes=force_real_classes,
            device=device,
            save_plots=True,
            plot_dir=plot_folder
        )

        save_path = output_dir / f"{class_name}_aug_{n}.hdr"

        envi.save_image(
            str(save_path),
            aug_cube,
            dtype=np.float32,
            force=True,
            interleave="bsq"
        )

    print(f"100 extrudes générés pour {class_name}")




import matplotlib.pyplot as plt
from pathlib import Path
import torch
import numpy as np

def generate_augmented_cube(
    cube,
    class_name,
    netG,
    wl_max10,
    wl_max20,
    force_real_classes=None,
    sam_threshold1=0.15,
    sam_threshold2=0.3,
    device="cuda",
    save_plots=False,
    plot_dir=None
):

    if force_real_classes is None:
        force_real_classes = {}

    B, H, W = cube.shape
    augmented_cube = np.zeros_like(cube)

    selected_10 = wl_max10[class_name]
    selected_20 = wl_max20[class_name]

    full_range_27 = list(range(27))

    if save_plots:
        plot_dir = Path(plot_dir)
        plot_dir.mkdir(parents=True, exist_ok=True)

    plot_count = 0

    for i in range(H):
        for j in range(W):

            real_spec = cube[:, i, j]

            if np.var(real_spec) < 1e-6:
                augmented_cube[:, i, j] = real_spec
                continue

            if class_name in force_real_classes:
                augmented_cube[:, i, j] = real_spec
                continue

            real_tensor = torch.tensor(2*real_spec-1, dtype=torch.float32).to(device)
            real_tensor = real_tensor.unsqueeze(0).unsqueeze(0)

            best_sam = 999
            best_fake = None

            # Génération de plusieurs spectres GAN et choix du meilleur SAM
            for _ in range(5):
                noise = torch.randn_like(real_tensor)
                fake = netG(noise).detach().cpu().squeeze().numpy()
                fake_denorm = (fake + 1) / 2
                sam = compute_sam(real_spec, fake_denorm)

                if sam < best_sam:
                    best_sam = sam
                    best_fake = fake_denorm

            gan_energy = np.linalg.norm(best_fake) + 1e-8

            if best_sam < sam_threshold1:
                selected = selected_10
            elif best_sam < sam_threshold2:
                selected = selected_20
            else:
                augmented_cube[:, i, j] = best_fake
                continue

            new_spec = best_fake.copy()

            for band in selected:
                if band == 0:
                    continue  # pas de point précédent pour le premier indice

                delta_real = real_spec[band] - real_spec[band-1]
                delta_gan = new_spec[band] - new_spec[band-1]

                # injecter la pente réelle sur le GAN, en conservant proportion GAN
                scale = abs(delta_gan) / (abs(delta_real) + 1e-8)
                new_spec[band] = new_spec[band-1] + delta_real * scale

            # remettre le spectre final sur la norme originale du GAN
            new_spec = new_spec / (np.linalg.norm(new_spec) + 1e-8) * gan_energy
            augmented_cube[:, i, j] = new_spec

            if save_plots and plot_count < 10:
                plt.figure(figsize=(8,5))
                plt.plot(real_spec, label="Real Spectrum", linewidth=2)
                plt.plot(best_fake, label="Best GAN Spectrum", linestyle="--")
                plt.plot(new_spec, label="Final Augmented Spectrum", linewidth=2)
                plt.title(f"{class_name} - SAM={best_sam:.4f}")
                plt.xlabel("Band Index")
                plt.ylabel("Reflectance")
                plt.legend()
                plt.tight_layout()
                plt.savefig(plot_dir / f"{class_name}_{plot_count}.png")
                plt.close()
                plot_count += 1

    return augmented_cube



import matplotlib.pyplot as plt
from pathlib import Path
import torch
import numpy as np

def generate_augmented_cube(
    cube,
    class_name,
    netG,
    wl_max10,
    wl_max20,
    sam_threshold1=0.15,
    sam_threshold2=0.3,
    device="cuda",
    save_plots=False,
    plot_dir=None
):
    stochastic_classes = ["classA", "classB", "classC"]

    B, H, W = cube.shape
    augmented_cube = np.zeros_like(cube)

    selected_10 = wl_max10.get(class_name, [])
    selected_20 = wl_max20.get(class_name, [])

    if save_plots:
        plot_dir = Path(plot_dir)
        plot_dir.mkdir(parents=True, exist_ok=True)

    plot_count = 0

    # Masque des spectres non nuls (variance > 1e-6)
    non_zero_mask = np.var(cube, axis=0) > 1e-6
    non_zero_spectra = cube[:, non_zero_mask]

    # Calcul de l'écart-type global sur tous les spectres non nuls
    if non_zero_spectra.size == 0:
        global_std = 0.0
    else:
        global_std = np.std(non_zero_spectra) + 1e-8

    for i in range(H):
        for j in range(W):
            real_spec = cube[:, i, j].copy()

            real_tensor = torch.tensor(2*real_spec-1, dtype=torch.float32).to(device)
            real_tensor = real_tensor.unsqueeze(0).unsqueeze(0)

            best_sam = 999
            best_fake = None

            for _ in range(5):
                noise = torch.randn_like(real_tensor)
                fake = netG(noise).detach().cpu().squeeze().numpy()
                fake_denorm = (fake + 1) / 2
                sam = compute_sam(real_spec, fake_denorm)
                if sam < best_sam:
                    best_sam = sam
                    best_fake = fake_denorm

            gan_energy = np.linalg.norm(best_fake) + 1e-8

            # Injection stochastique si SAM > threshold2 ou classe stochastique
            if best_sam > sam_threshold2 or class_name in stochastic_classes:
                noise = np.random.normal(0, global_std, size=B)
                new_spec = real_spec + noise
                augmented_cube[:, i, j] = new_spec

                if save_plots and plot_count < 10:
                    plt.figure(figsize=(8,5))
                    plt.plot(real_spec, label="Real Spectrum", linewidth=2)
                    plt.plot(new_spec, label="Augmented Spectrum (stochastic)", linewidth=2)
                    plt.title(f"{class_name} - SAM={best_sam:.4f}")
                    plt.xlabel("Band Index")
                    plt.ylabel("Reflectance")
                    plt.legend()
                    plt.tight_layout()
                    plt.savefig(plot_dir / f"{class_name}_{plot_count}.png")
                    plt.close()
                    plot_count += 1
                continue

            # Injection pente locale GAN pour bandes sélectionnées
            if best_sam < sam_threshold1:
                selected = selected_10
            else:
                selected = selected_20

            new_spec = best_fake.copy()
            for band in selected:
                if band == 0:
                    continue
                delta_real = real_spec[band] - real_spec[band-1]
                delta_gan = new_spec[band] - new_spec[band-1]
                scale = abs(delta_gan) / (abs(delta_real) + 1e-8)
                new_spec[band] = new_spec[band-1] + delta_real * scale

            new_spec = new_spec / (np.linalg.norm(new_spec) + 1e-8) * gan_energy
            augmented_cube[:, i, j] = new_spec

            if save_plots and plot_count < 10:
                plt.figure(figsize=(8,5))
                plt.plot(real_spec, label="Real Spectrum", linewidth=2)
                plt.plot(best_fake, label="Best GAN Spectrum", linestyle="--")
                plt.plot(new_spec, label="Final Augmented Spectrum", linewidth=2)
                plt.title(f"{class_name} - SAM={best_sam:.4f}")
                plt.xlabel("Band Index")
                plt.ylabel("Reflectance")
                plt.legend()
                plt.tight_layout()
                plt.savefig(plot_dir / f"{class_name}_{plot_count}.png")
                plt.close()
                plot_count += 1

    return augmented_cube


import matplotlib.pyplot as plt
from pathlib import Path
import torch
import numpy as np

def inject_derivative(real_spec, gan_spec, selected_indices):

    real_smooth = np.convolve(real_spec, np.ones(3)/3, mode='same')
    gan_smooth  = np.convolve(gan_spec,  np.ones(3)/3, mode='same')

    D_real = np.gradient(real_smooth)
    D_gan  = np.gradient(gan_smooth)

    M = np.zeros_like(real_spec)
    M[selected_indices] = 1

    D_mix = M * D_real + (1 - M) * D_gan

    S_aug = np.cumsum(D_mix)
    S_aug = S_aug - np.mean(S_aug) + np.mean(gan_spec)

    return S_aug


def generate_augmented_cube(
    cube,
    class_name,
    netG,
    wl_max10,
    wl_max20,
    force_real_classes=None,
    sam_threshold1=0.15,
    sam_threshold2=0.3,
    device="cuda",
    save_plots=False,
    plot_dir=None
):

    if force_real_classes is None:
        force_real_classes = {}

    B, H, W = cube.shape
    augmented_cube = np.zeros_like(cube)

    selected_10 = wl_max10[class_name]
    selected_20 = wl_max20[class_name]

    full_range_27 = list(range(27))

    if save_plots:
        plot_dir = Path(plot_dir)
        plot_dir.mkdir(parents=True, exist_ok=True)

    plot_count = 0

    for i in range(H):
        for j in range(W):

            real_spec = cube[:, i, j]

            if np.var(real_spec) < 1e-6:
                augmented_cube[:, i, j] = real_spec
                continue

            if class_name in force_real_classes:
                augmented_cube[:, i, j] = real_spec
                continue

            real_tensor = torch.tensor(2 * real_spec - 1, dtype=torch.float32).to(device)
            real_tensor = real_tensor.unsqueeze(0).unsqueeze(0)

            best_sam = 999
            best_fake = None

            for _ in range(5):
                noise = torch.randn_like(real_tensor)
                fake = netG(noise).detach().cpu().squeeze().numpy()
                fake_denorm = (fake + 1) / 2
                sam = compute_sam(real_spec, fake_denorm)

                if sam < best_sam:
                    best_sam = sam
                    best_fake = fake_denorm

            if best_sam < sam_threshold1:

                if list(selected_10) == full_range_27:
                    new_spec = best_fake.copy()
                else:
                    new_spec = inject_derivative(real_spec, best_fake, selected_10)

            elif best_sam < sam_threshold2:

                if list(selected_20) == full_range_27:
                    new_spec = best_fake.copy()
                else:
                    new_spec = inject_derivative(real_spec, best_fake, selected_20)

            else:
                new_spec = real_spec

            augmented_cube[:, i, j] = new_spec

            if save_plots and plot_count < 10:

                plt.figure(figsize=(8, 5))
                plt.plot(real_spec, label="Real Spectrum", linewidth=2)
                plt.plot(best_fake, label="Best GAN Spectrum", linestyle="--")
                plt.plot(new_spec, label="Final Augmented Spectrum", linewidth=2)

                plt.title(f"{class_name} - SAM={best_sam:.4f}")
                plt.xlabel("Band Index")
                plt.ylabel("Reflectance")
                plt.legend()
                plt.tight_layout()

                plt.savefig(plot_dir / f"{class_name}_{plot_count}.png")
                plt.close()

                plot_count += 1

    return augmented_cube


import matplotlib.pyplot as plt
from pathlib import Path
import torch
import numpy as np


def inject_signature(real_spec, gan_spec, selected_indices, beta=0.7):

    local_mean = np.convolve(real_spec, np.ones(3)/3, mode='same')
    local_mean[local_mean == 0] = 1e-8

    ratio = real_spec / local_mean

    M = np.zeros_like(real_spec)
    M[selected_indices] = 1

    modulation = 1 + beta * M * (ratio - 1)

    S_aug = gan_spec * modulation

    S_aug = S_aug - np.mean(S_aug) + np.mean(gan_spec)

    return S_aug


def generate_augmented_cube(
    cube,
    class_name,
    netG,
    wl_max10,
    wl_max20,
    force_real_classes=None,
    sam_threshold1=0.15,
    sam_threshold2=0.3,
    device="cuda",
    save_plots=False,
    plot_dir=None
):

    if force_real_classes is None:
        force_real_classes = {}

    B, H, W = cube.shape
    augmented_cube = np.zeros_like(cube)

    selected_10 = wl_max10[class_name]
    selected_20 = wl_max20[class_name]

    full_range_27 = list(range(27))

    if save_plots:
        plot_dir = Path(plot_dir)
        plot_dir.mkdir(parents=True, exist_ok=True)

    plot_count = 0

    for i in range(H):
        for j in range(W):

            real_spec = cube[:, i, j]

            if np.var(real_spec) < 1e-6:
                augmented_cube[:, i, j] = real_spec
                continue

            if class_name in force_real_classes:
                augmented_cube[:, i, j] = real_spec
                continue

            real_tensor = torch.tensor(2 * real_spec - 1, dtype=torch.float32).to(device)
            real_tensor = real_tensor.unsqueeze(0).unsqueeze(0)

            best_sam = 999
            best_fake = None

            for _ in range(5):
                noise = torch.randn_like(real_tensor)
                fake = netG(noise).detach().cpu().squeeze().numpy()
                fake_denorm = (fake + 1) / 2
                sam = compute_sam(real_spec, fake_denorm)

                if sam < best_sam:
                    best_sam = sam
                    best_fake = fake_denorm

            if best_sam < sam_threshold1:

                if list(selected_10) == full_range_27:
                    new_spec = best_fake.copy()
                else:
                    new_spec = inject_signature(real_spec, best_fake, selected_10)

            elif best_sam < sam_threshold2:

                if list(selected_20) == full_range_27:
                    new_spec = best_fake.copy()
                else:
                    new_spec = inject_signature(real_spec, best_fake, selected_20)

            else:
                new_spec = real_spec

            augmented_cube[:, i, j] = new_spec

            if save_plots and plot_count < 10:

                plt.figure(figsize=(8, 5))
                plt.plot(real_spec, label="Real Spectrum", linewidth=2)
                plt.plot(best_fake, label="Best GAN Spectrum", linestyle="--")
                plt.plot(new_spec, label="Final Augmented Spectrum", linewidth=2)

                plt.title(f"{class_name} - SAM={best_sam:.4f}")
                plt.xlabel("Band Index")
                plt.ylabel("Reflectance")
                plt.legend()
                plt.tight_layout()

                plt.savefig(plot_dir / f"{class_name}_{plot_count}.png")
                plt.close()

                plot_count += 1

    return augmented_cube