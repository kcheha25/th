import pandas as pd

def save_selected_wavelengths(groups, class_names, class_spectra, save_path_10, save_path_20):
    
    results_10 = {}
    results_20 = {}
    
    for group in groups:
        sel_10 = select_mrmr_bands_for_group(class_spectra, group, n_features=10)
        sel_20 = select_mrmr_bands_for_group(class_spectra, group, n_features=20)
        
        for label in group:
            class_name = class_names[label]
            results_10[class_name] = sel_10
            results_20[class_name] = sel_20
    
    df10 = pd.DataFrame(dict([(k, pd.Series(v)) for k, v in results_10.items()]))
    df20 = pd.DataFrame(dict([(k, pd.Series(v)) for k, v in results_20.items()]))

    df10.to_excel(save_path_10, index=False)
    df20.to_excel(save_path_20, index=False)

    print("Fichiers Excel sauvegardés")


save_selected_wavelengths(
    groups,
    dataset.class_names,
    class_spectra,
    "wl_max10.xlsx",
    "wl_max20.xlsx"
)


def load_selected_wavelengths(path_excel):
    df = pd.read_excel(path_excel)
    selected = {}
    for col in df.columns:
        selected[col] = df[col].dropna().astype(int).tolist()
    return selected

wl_max10 = load_selected_wavelengths("wl_max10.xlsx")
wl_max20 = load_selected_wavelengths("wl_max20.xlsx")


import torch
import numpy as np
from spectral import envi
from pathlib import Path

def generate_augmented_cube(
    cube,
    class_name,
    netG,
    wl_max10,
    wl_max20,
    sam_threshold1=0.15,
    sam_threshold2=0.3,
    device="cuda"
):

    B, H, W = cube.shape
    augmented_cube = np.zeros_like(cube)

    selected_10 = wl_max10[class_name]
    selected_20 = wl_max20[class_name]

    for i in range(H):
        for j in range(W):
            real_spec = cube[:, i, j]

            if np.var(real_spec) < 1e-6:
                augmented_cube[:, i, j] = real_spec
                continue

            real_tensor = torch.tensor(2*real_spec-1, dtype=torch.float32).to(device)

            best_sam = 999
            best_fake = None

            for _ in range(5):
                noise = torch.randn_like(real_tensor)
                fake = netG(noise).detach().cpu().numpy()
                fake_denorm = (fake + 1) / 2
                sam = compute_sam(real_spec, fake_denorm)

                if sam < best_sam:
                    best_sam = sam
                    best_fake = fake_denorm

            if best_sam < sam_threshold1:
                new_spec = best_fake.copy()
                new_spec[selected_10] = real_spec[selected_10]

            elif best_sam < sam_threshold2:
                new_spec = best_fake.copy()
                new_spec[selected_20] = real_spec[selected_20]

            else:
                new_spec = real_spec  

            augmented_cube[:, i, j] = new_spec

    return augmented_cube


def generate_100_augmented_extrudes(
    input_cube_path,
    class_name,
    results_dir,
    wl_max10,
    wl_max20,
    output_dir,
    device="cuda"
):

    hdr = envi.open(input_cube_path)
    cube = np.array(hdr.load(), dtype=np.float32)

    netG = torch.load(f"./results/{class_name}/netG_best.pth")
    netG.to(device)
    netG.eval()

    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    for n in range(100):

        aug_cube = generate_augmented_cube(
            cube,
            class_name,
            netG,
            wl_max10,
            wl_max20,
            device=device
        )

        save_path = output_dir / f"{class_name}_aug_{n}.hdr"

        envi.save_image(
            str(save_path),
            aug_cube,
            dtype=np.float32,
            force=True,
            interleave="bsq"
        )

    print(f"100 extrudes générés pour {class_name}")


import matplotlib.pyplot as plt


def generate_augmented_cube(
    cube,
    class_name,
    netG,
    wl_max10,
    wl_max20,
    sam_threshold1=0.15,
    sam_threshold2=0.3,
    device="cuda",
    save_plots=False,
    plot_dir=None
):

    B, H, W = cube.shape
    augmented_cube = np.zeros_like(cube)

    selected_10 = wl_max10[class_name]
    selected_20 = wl_max20[class_name]

    if save_plots:
        plot_dir = Path(plot_dir)
        plot_dir.mkdir(parents=True, exist_ok=True)

    for i in range(H):
        for j in range(W):

            real_spec = cube[:, i, j]

            if np.var(real_spec) < 1e-6:
                augmented_cube[:, i, j] = real_spec
                continue

            real_tensor = torch.tensor(2*real_spec-1, dtype=torch.float32).to(device)

            best_sam = 999
            best_fake = None

            for _ in range(5):
                noise = torch.randn_like(real_tensor)
                fake = netG(noise).detach().cpu().numpy()
                fake_denorm = (fake + 1) / 2
                sam = compute_sam(real_spec, fake_denorm)

                if sam < best_sam:
                    best_sam = sam
                    best_fake = fake_denorm

            if best_sam < sam_threshold1:
                new_spec = best_fake.copy()
                new_spec[selected_10] = real_spec[selected_10]

            elif best_sam < sam_threshold2:
                new_spec = best_fake.copy()
                new_spec[selected_20] = real_spec[selected_20]

            else:
                new_spec = real_spec

            augmented_cube[:, i, j] = new_spec

            # -------- PLOT --------
            if save_plots:

                plt.figure(figsize=(8,5))
                plt.plot(real_spec, label="Real Spectrum", linewidth=2)
                plt.plot(best_fake, label="Best GAN Spectrum", linestyle="--")
                plt.plot(new_spec, label="Final Augmented Spectrum", linewidth=2)

                plt.title(f"{class_name} - Pixel ({i},{j}) - SAM={best_sam:.4f}")
                plt.xlabel("Band Index")
                plt.ylabel("Reflectance")
                plt.legend()
                plt.tight_layout()

                plt.savefig(plot_dir / f"{class_name}_{i}_{j}.png")
                plt.close()

    return augmented_cube

def generate_100_augmented_extrudes(
    input_cube_path,
    class_name,
    results_dir,
    wl_max10,
    wl_max20,
    output_dir,
    device="cuda"
):

    hdr = envi.open(input_cube_path)
    cube = np.array(hdr.load(), dtype=np.float32)

    netG = torch.load(f"./results/{class_name}/netG_best.pth")
    netG.to(device)
    netG.eval()

    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    for n in range(100):

        plot_folder = output_dir / f"plots_aug_{n}"

        aug_cube = generate_augmented_cube(
            cube,
            class_name,
            netG,
            wl_max10,
            wl_max20,
            device=device,
            save_plots=True,
            plot_dir=plot_folder
        )

        save_path = output_dir / f"{class_name}_aug_{n}.hdr"

        envi.save_image(
            str(save_path),
            aug_cube,
            dtype=np.float32,
            force=True,
            interleave="bsq"
        )

    print(f"100 extrudes générés pour {class_name}")



import matplotlib.pyplot as plt
from pathlib import Path
import torch
import numpy as np

def generate_augmented_cube(
    cube,
    class_name,
    netG,
    wl_max10,
    wl_max20,
    force_real_classes=None,
    sam_threshold1=0.15,
    sam_threshold2=0.3,
    device="cuda",
    save_plots=False,
    plot_dir=None
):

    if force_real_classes is None:
        force_real_classes = {}

    B, H, W = cube.shape
    augmented_cube = np.zeros_like(cube)

    selected_10 = wl_max10[class_name]
    selected_20 = wl_max20[class_name]

    full_range_27 = list(range(27))

    if save_plots:
        plot_dir = Path(plot_dir)
        plot_dir.mkdir(parents=True, exist_ok=True)

    plot_count = 0

    for i in range(H):
        for j in range(W):

            real_spec = cube[:, i, j]

            if np.var(real_spec) < 1e-6:
                augmented_cube[:, i, j] = real_spec
                continue

            if class_name in force_real_classes:
                augmented_cube[:, i, j] = real_spec
                continue

            real_tensor = torch.tensor(2*real_spec-1, dtype=torch.float32).to(device)
            real_tensor = real_tensor.unsqueeze(0).unsqueeze(0)

            best_sam = 999
            best_fake = None

            for _ in range(5):
                noise = torch.randn_like(real_tensor)
                fake = netG(noise).detach().cpu().squeeze().numpy()
                fake_denorm = (fake + 1) / 2
                sam = compute_sam(real_spec, fake_denorm)

                if sam < best_sam:
                    best_sam = sam
                    best_fake = fake_denorm

            if best_sam < sam_threshold1:

                if list(selected_10) == full_range_27:
                    new_spec = best_fake.copy()
                else:
                    new_spec = best_fake.copy()
                    new_spec[selected_10] = real_spec[selected_10]

            elif best_sam < sam_threshold2:

                if list(selected_20) == full_range_27:
                    new_spec = best_fake.copy()
                else:
                    new_spec = best_fake.copy()
                    new_spec[selected_20] = real_spec[selected_20]

            else:
                new_spec = real_spec

            augmented_cube[:, i, j] = new_spec

            if save_plots and plot_count < 10:

                plt.figure(figsize=(8,5))
                plt.plot(real_spec, label="Real Spectrum", linewidth=2)
                plt.plot(best_fake, label="Best GAN Spectrum", linestyle="--")
                plt.plot(new_spec, label="Final Augmented Spectrum", linewidth=2)

                plt.title(f"{class_name} - SAM={best_sam:.4f}")
                plt.xlabel("Band Index")
                plt.ylabel("Reflectance")
                plt.legend()
                plt.tight_layout()

                plt.savefig(plot_dir / f"{class_name}_{plot_count}.png")
                plt.close()

                plot_count += 1

    return augmented_cube


def generate_100_augmented_extrudes(
    input_cube_path,
    class_name,
    results_dir,
    wl_max10,
    wl_max20,
    output_dir,
    force_real_classes=None,
    device="cuda"
):

    hdr = envi.open(input_cube_path)
    cube = np.array(hdr.load(), dtype=np.float32)

    netG = torch.load(f"./results/{class_name}/netG_best.pth")
    netG.to(device)
    netG.eval()

    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    for n in range(100):

        plot_folder = output_dir / f"plots_aug_{n}"

        aug_cube = generate_augmented_cube(
            cube,
            class_name,
            netG,
            wl_max10,
            wl_max20,
            force_real_classes=force_real_classes,
            device=device,
            save_plots=True,
            plot_dir=plot_folder
        )

        save_path = output_dir / f"{class_name}_aug_{n}.hdr"

        envi.save_image(
            str(save_path),
            aug_cube,
            dtype=np.float32,
            force=True,
            interleave="bsq"
        )

    print(f"100 extrudes générés pour {class_name}")




import matplotlib.pyplot as plt
from pathlib import Path
import torch
import numpy as np

def generate_augmented_cube(
    cube,
    class_name,
    netG,
    wl_max10,
    wl_max20,
    force_real_classes=None,
    sam_threshold1=0.15,
    sam_threshold2=0.3,
    device="cuda",
    save_plots=False,
    plot_dir=None
):

    if force_real_classes is None:
        force_real_classes = {}

    B, H, W = cube.shape
    augmented_cube = np.zeros_like(cube)

    selected_10 = wl_max10[class_name]
    selected_20 = wl_max20[class_name]

    full_range_27 = list(range(27))

    if save_plots:
        plot_dir = Path(plot_dir)
        plot_dir.mkdir(parents=True, exist_ok=True)

    plot_count = 0

    for i in range(H):
        for j in range(W):

            real_spec = cube[:, i, j]

            if np.var(real_spec) < 1e-6:
                augmented_cube[:, i, j] = real_spec
                continue

            if class_name in force_real_classes:
                augmented_cube[:, i, j] = real_spec
                continue

            real_tensor = torch.tensor(2*real_spec-1, dtype=torch.float32).to(device)
            real_tensor = real_tensor.unsqueeze(0).unsqueeze(0)

            best_sam = 999
            best_fake = None

            # Génération de plusieurs spectres GAN et choix du meilleur SAM
            for _ in range(5):
                noise = torch.randn_like(real_tensor)
                fake = netG(noise).detach().cpu().squeeze().numpy()
                fake_denorm = (fake + 1) / 2
                sam = compute_sam(real_spec, fake_denorm)

                if sam < best_sam:
                    best_sam = sam
                    best_fake = fake_denorm

            gan_energy = np.linalg.norm(best_fake) + 1e-8

            if best_sam < sam_threshold1:
                selected = selected_10
            elif best_sam < sam_threshold2:
                selected = selected_20
            else:
                augmented_cube[:, i, j] = best_fake
                continue

            new_spec = best_fake.copy()

            for band in selected:
                if band == 0:
                    continue  # pas de point précédent pour le premier indice

                delta_real = real_spec[band] - real_spec[band-1]
                delta_gan = new_spec[band] - new_spec[band-1]

                # injecter la pente réelle sur le GAN, en conservant proportion GAN
                scale = abs(delta_gan) / (abs(delta_real) + 1e-8)
                new_spec[band] = new_spec[band-1] + delta_real * scale

            # remettre le spectre final sur la norme originale du GAN
            new_spec = new_spec / (np.linalg.norm(new_spec) + 1e-8) * gan_energy
            augmented_cube[:, i, j] = new_spec

            if save_plots and plot_count < 10:
                plt.figure(figsize=(8,5))
                plt.plot(real_spec, label="Real Spectrum", linewidth=2)
                plt.plot(best_fake, label="Best GAN Spectrum", linestyle="--")
                plt.plot(new_spec, label="Final Augmented Spectrum", linewidth=2)
                plt.title(f"{class_name} - SAM={best_sam:.4f}")
                plt.xlabel("Band Index")
                plt.ylabel("Reflectance")
                plt.legend()
                plt.tight_layout()
                plt.savefig(plot_dir / f"{class_name}_{plot_count}.png")
                plt.close()
                plot_count += 1

    return augmented_cube



import matplotlib.pyplot as plt
from pathlib import Path
import torch
import numpy as np

def generate_augmented_cube(
    cube,
    class_name,
    netG,
    wl_max10,
    wl_max20,
    sam_threshold1=0.15,
    sam_threshold2=0.3,
    device="cuda",
    save_plots=False,
    plot_dir=None
):
    stochastic_classes = ["classA", "classB", "classC"]

    B, H, W = cube.shape
    augmented_cube = np.zeros_like(cube)

    selected_10 = wl_max10.get(class_name, [])
    selected_20 = wl_max20.get(class_name, [])

    if save_plots:
        plot_dir = Path(plot_dir)
        plot_dir.mkdir(parents=True, exist_ok=True)

    plot_count = 0

    # Masque des spectres non nuls (variance > 1e-6)
    non_zero_mask = np.var(cube, axis=0) > 1e-6
    non_zero_spectra = cube[:, non_zero_mask]

    # Calcul de l'écart-type global sur tous les spectres non nuls
    if non_zero_spectra.size == 0:
        global_std = 0.0
    else:
        global_std = np.std(non_zero_spectra) + 1e-8

    for i in range(H):
        for j in range(W):
            real_spec = cube[:, i, j].copy()

            real_tensor = torch.tensor(2*real_spec-1, dtype=torch.float32).to(device)
            real_tensor = real_tensor.unsqueeze(0).unsqueeze(0)

            best_sam = 999
            best_fake = None

            for _ in range(5):
                noise = torch.randn_like(real_tensor)
                fake = netG(noise).detach().cpu().squeeze().numpy()
                fake_denorm = (fake + 1) / 2
                sam = compute_sam(real_spec, fake_denorm)
                if sam < best_sam:
                    best_sam = sam
                    best_fake = fake_denorm

            gan_energy = np.linalg.norm(best_fake) + 1e-8

            # Injection stochastique si SAM > threshold2 ou classe stochastique
            if best_sam > sam_threshold2 or class_name in stochastic_classes:
                noise = np.random.normal(0, global_std, size=B)
                new_spec = real_spec + noise
                augmented_cube[:, i, j] = new_spec

                if save_plots and plot_count < 10:
                    plt.figure(figsize=(8,5))
                    plt.plot(real_spec, label="Real Spectrum", linewidth=2)
                    plt.plot(new_spec, label="Augmented Spectrum (stochastic)", linewidth=2)
                    plt.title(f"{class_name} - SAM={best_sam:.4f}")
                    plt.xlabel("Band Index")
                    plt.ylabel("Reflectance")
                    plt.legend()
                    plt.tight_layout()
                    plt.savefig(plot_dir / f"{class_name}_{plot_count}.png")
                    plt.close()
                    plot_count += 1
                continue

            # Injection pente locale GAN pour bandes sélectionnées
            if best_sam < sam_threshold1:
                selected = selected_10
            else:
                selected = selected_20

            new_spec = best_fake.copy()
            for band in selected:
                if band == 0:
                    continue
                delta_real = real_spec[band] - real_spec[band-1]
                delta_gan = new_spec[band] - new_spec[band-1]
                scale = abs(delta_gan) / (abs(delta_real) + 1e-8)
                new_spec[band] = new_spec[band-1] + delta_real * scale

            new_spec = new_spec / (np.linalg.norm(new_spec) + 1e-8) * gan_energy
            augmented_cube[:, i, j] = new_spec

            if save_plots and plot_count < 10:
                plt.figure(figsize=(8,5))
                plt.plot(real_spec, label="Real Spectrum", linewidth=2)
                plt.plot(best_fake, label="Best GAN Spectrum", linestyle="--")
                plt.plot(new_spec, label="Final Augmented Spectrum", linewidth=2)
                plt.title(f"{class_name} - SAM={best_sam:.4f}")
                plt.xlabel("Band Index")
                plt.ylabel("Reflectance")
                plt.legend()
                plt.tight_layout()
                plt.savefig(plot_dir / f"{class_name}_{plot_count}.png")
                plt.close()
                plot_count += 1

    return augmented_cube


import matplotlib.pyplot as plt
from pathlib import Path
import torch
import numpy as np

def inject_derivative(real_spec, gan_spec, selected_indices):

    real_smooth = np.convolve(real_spec, np.ones(3)/3, mode='same')
    gan_smooth  = np.convolve(gan_spec,  np.ones(3)/3, mode='same')

    D_real = np.gradient(real_smooth)
    D_gan  = np.gradient(gan_smooth)

    M = np.zeros_like(real_spec)
    M[selected_indices] = 1

    D_mix = M * D_real + (1 - M) * D_gan

    S_aug = np.cumsum(D_mix)
    S_aug = S_aug - np.mean(S_aug) + np.mean(gan_spec)

    return S_aug


def generate_augmented_cube(
    cube,
    class_name,
    netG,
    wl_max10,
    wl_max20,
    force_real_classes=None,
    sam_threshold1=0.15,
    sam_threshold2=0.3,
    device="cuda",
    save_plots=False,
    plot_dir=None
):

    if force_real_classes is None:
        force_real_classes = {}

    B, H, W = cube.shape
    augmented_cube = np.zeros_like(cube)

    selected_10 = wl_max10[class_name]
    selected_20 = wl_max20[class_name]

    full_range_27 = list(range(27))

    if save_plots:
        plot_dir = Path(plot_dir)
        plot_dir.mkdir(parents=True, exist_ok=True)

    plot_count = 0

    for i in range(H):
        for j in range(W):

            real_spec = cube[:, i, j]

            if np.var(real_spec) < 1e-6:
                augmented_cube[:, i, j] = real_spec
                continue

            if class_name in force_real_classes:
                augmented_cube[:, i, j] = real_spec
                continue

            real_tensor = torch.tensor(2 * real_spec - 1, dtype=torch.float32).to(device)
            real_tensor = real_tensor.unsqueeze(0).unsqueeze(0)

            best_sam = 999
            best_fake = None

            for _ in range(5):
                noise = torch.randn_like(real_tensor)
                fake = netG(noise).detach().cpu().squeeze().numpy()
                fake_denorm = (fake + 1) / 2
                sam = compute_sam(real_spec, fake_denorm)

                if sam < best_sam:
                    best_sam = sam
                    best_fake = fake_denorm

            if best_sam < sam_threshold1:

                if list(selected_10) == full_range_27:
                    new_spec = best_fake.copy()
                else:
                    new_spec = inject_derivative(real_spec, best_fake, selected_10)

            elif best_sam < sam_threshold2:

                if list(selected_20) == full_range_27:
                    new_spec = best_fake.copy()
                else:
                    new_spec = inject_derivative(real_spec, best_fake, selected_20)

            else:
                new_spec = real_spec

            augmented_cube[:, i, j] = new_spec

            if save_plots and plot_count < 10:

                plt.figure(figsize=(8, 5))
                plt.plot(real_spec, label="Real Spectrum", linewidth=2)
                plt.plot(best_fake, label="Best GAN Spectrum", linestyle="--")
                plt.plot(new_spec, label="Final Augmented Spectrum", linewidth=2)

                plt.title(f"{class_name} - SAM={best_sam:.4f}")
                plt.xlabel("Band Index")
                plt.ylabel("Reflectance")
                plt.legend()
                plt.tight_layout()

                plt.savefig(plot_dir / f"{class_name}_{plot_count}.png")
                plt.close()

                plot_count += 1

    return augmented_cube


import matplotlib.pyplot as plt
from pathlib import Path
import torch
import numpy as np

def inject_local_variation(real_spec, gan_spec, selected_indices, window_size=1):
    S_aug = gan_spec.copy()
    B = len(real_spec)
    
    for idx in selected_indices:
        i = int(idx)
        start = max(0, i - window_size)
        end   = min(B, i + window_size + 1)
        
        real_win = real_spec[start:end]
        gan_win  = gan_spec[start:end]
        
        delta_real = np.diff(real_win)
        
        aug_win = [gan_win[0]]  
        for d in delta_real:
            aug_win.append(aug_win[-1] + d)
        
        S_aug[start:end] = aug_win
        
    return S_aug


def generate_augmented_cube(
    cube,
    class_name,
    netG,
    wl_max10,
    wl_max20,
    force_real_classes=None,
    sam_threshold1=0.10,
    device="cuda",
    save_plots=False,
    plot_dir=None,
    beta=1.0,
    window_size=1
):

    if force_real_classes is None:
        force_real_classes = {}

    B, H, W = cube.shape
    augmented_cube = np.zeros_like(cube)

    selected_10 = wl_max10[class_name]
    selected_20 = wl_max20[class_name]

    full_range_54 = list(range(54))

    if save_plots:
        plot_dir = Path(plot_dir)
        plot_dir.mkdir(parents=True, exist_ok=True)

    plot_count = 0

    for i in range(H):
        for j in range(W):

            real_spec = cube[:, i, j]

            best_sam = 999
            best_fake = None

            for _ in range(5):
                noise = torch.randn_like(real_tensor)
                fake = netG(noise).detach().cpu().squeeze().numpy()
                fake_denorm = (fake + 1) / 2
                sam = compute_sam(real_spec, fake_denorm)

                if sam < best_sam:
                    best_sam = sam
                    best_fake = fake_denorm

            if best_sam < sam_threshold1:

                if list(selected_20) == full_range_54:
                    new_spec = best_fake.copy()
                else:
                    new_spec = inject_local_variation(real_spec, best_fake, selected_20, beta=beta, window_size=window_size)
                    wl_to_plot = selected_20

            else:
                new_spec = real_spec
                wl_to_plot = []

            augmented_cube[:, i, j] = new_spec

            if save_plots and plot_count < 10:

                plt.figure(figsize=(8, 5))
                plt.plot(real_spec, label="Real Spectrum", linewidth=2)
                plt.plot(best_fake, label="Best GAN Spectrum", linestyle="--")
                plt.plot(new_spec, label="Final Augmented Spectrum", linewidth=2)

                for wl in wl_to_plot:
                    plt.axvline(x=int(wl), color='red', linestyle=':', linewidth=1)

                plt.title(f"{class_name} - SAM={best_sam:.4f}")
                plt.xlabel("Band Index")
                plt.ylabel("Reflectance")
                plt.legend()
                plt.tight_layout()

                plt.savefig(plot_dir / f"{class_name}_{plot_count}.png")
                plt.close()

                plot_count += 1

    return augmented_cube

def generate_100_augmented_extrudes(
    input_cube_path,
    class_name,
    results_dir,
    wl_max10,
    wl_max20,
    output_dir,
    force_real_classes=None,
    device="cuda"
):

    hdr = envi.open(input_cube_path)
    cube = np.array(hdr.load(), dtype=np.float32)

    netG = torch.load(f"./results/{class_name}/netG_best.pth")
    netG.to(device)
    netG.eval()

    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    for n in range(100):

        plot_folder = output_dir / f"plots_aug_{n}"

        aug_cube = generate_augmented_cube(
            cube,
            class_name,
            netG,
            wl_max10,
            wl_max20,
            force_real_classes=force_real_classes,
            device=device,
            save_plots=True,
            plot_dir=plot_folder
        )

        save_path = output_dir / f"{class_name}_aug_{n}.hdr"

        envi.save_image(
            str(save_path),
            aug_cube,
            dtype=np.float32,
            force=True,
            interleave="bsq"
        )

    print(f"100 extrudes générés pour {class_name}")

#############################################3
import numpy as np
from pathlib import Path
from spectral import envi
import torch
from torch.utils.data import Dataset
import matplotlib.pyplot as plt

class SpectralPixelDataset(Dataset):
    def __init__(self, root_dir, null_threshold=1e-6):
        self.root_dir = Path(root_dir)
        self.null_threshold = null_threshold
        self.samples = []
        self.class_map = {}
        self.class_names = []
        class_counter = 0
        hdr_files = list(self.root_dir.rglob("*.hdr"))
        self.file_class_map = {}

        for hdr_file in sorted(hdr_files):
            name = hdr_file.stem
            prefix = name.split("_")[0]
            if prefix not in self.class_map:
                self.class_map[prefix] = class_counter
                self.class_names.append(prefix)
                class_counter += 1
            class_id = self.class_map[prefix]
            self.file_class_map[hdr_file] = prefix

            img = envi.open(str(hdr_file))
            cube = np.array(img.load(), dtype=np.float32)
            B, H, W = cube.shape
            spectra = cube.reshape(B, -1).T
            for s in spectra:
                if np.var(s) > self.null_threshold:
                    self.samples.append((s, class_id))

        print(f"Dataset chargé : {len(self.samples)} spectres non nuls")
        print(f"Classes : {self.class_names}")

    def __len__(self):
        return len(self.samples)

    def __getitem__(self, idx):
        return self.samples[idx]

def get_spectra_class(dataset, class_name):
    spectra_list = []
    class_id = dataset.class_map[class_name]
    for s, cid in dataset:
        if cid == class_id:
            spectra_list.append(s)
    return np.array(spectra_list)

def inject_local_variation(real_spec, gan_spec, selected_indices, beta=1.0, window_size=1):
    S_aug = gan_spec.copy()
    B = len(real_spec)
    for idx in selected_indices:
        i = int(idx)
        start = max(0, i - window_size)
        end   = min(B, i + window_size + 1)
        real_win = real_spec[start:end]
        gan_win  = gan_spec[start:end]
        delta_real = np.diff(real_win)
        aug_win = [gan_win[0]]
        for d in delta_real:
            aug_win.append(aug_win[-1] + d)
        S_aug[start:end] = aug_win
    return S_aug

# -------------------------------
# Bruit avec wl aléatoire
# -------------------------------
def augment_with_class_noise(real_spec, spectra_class, alpha=1.0):
    # choisir un indice aléatoire
    wl_index = np.random.randint(0, spectra_class.shape[1])
    sigma = np.std(spectra_class[:, wl_index])
    noise = np.random.randn() * sigma * alpha
    S_aug = np.clip(real_spec + noise, 0, 1)
    return S_aug

def compute_sam(spec1, spec2):
    num = np.dot(spec1, spec2)
    denom = np.linalg.norm(spec1) * np.linalg.norm(spec2)
    cos_theta = np.clip(num / denom, -1, 1)
    return np.arccos(cos_theta)

def generate_augmented_cube(
    cube,
    class_name,
    netG,
    wl_max10,
    wl_max20,
    spectra_class=None,
    alpha_noise=1.0,
    force_real_classes=None,
    sam_threshold1=0.10,
    device="cuda",
    save_plots=False,
    plot_dir=None,
    beta=1.0,
    window_size=1
):
    if force_real_classes is None:
        force_real_classes = {}

    B, H, W = cube.shape
    augmented_cube = np.zeros_like(cube)

    selected_10 = [int(x) for x in wl_max10[class_name]]
    selected_20 = [int(x) for x in wl_max20[class_name]]
    full_range_B = list(range(B))

    if save_plots and plot_dir is not None:
        plot_dir = Path(plot_dir)
        plot_dir.mkdir(parents=True, exist_ok=True)

    plot_count = 0
    for i in range(H):
        for j in range(W):
            real_spec = cube[:, i, j]
            best_sam = 999
            best_fake = None

            real_tensor = torch.tensor(real_spec, dtype=torch.float32).unsqueeze(0).unsqueeze(0).to(device)

            for _ in range(5):
                noise = torch.randn_like(real_tensor)
                fake = netG(noise).detach().cpu().squeeze().numpy()
                sam = compute_sam(real_spec, fake)
                if sam < best_sam:
                    best_sam = sam
                    best_fake = fake

            wl_to_plot = []

            if (class_name in ["A1","B1","C2","D5"] or best_sam > sam_threshold1) and spectra_class is not None:
                new_spec = augment_with_class_noise(real_spec, spectra_class, alpha=alpha_noise)
            elif best_sam < sam_threshold1:
                if list(selected_20) == full_range_B:
                    new_spec = best_fake.copy()
                else:
                    new_spec = inject_local_variation(real_spec, best_fake, selected_20, beta=beta, window_size=window_size)
                    wl_to_plot = selected_20
            else:
                new_spec = real_spec

            augmented_cube[:, i, j] = new_spec

            if save_plots and plot_count < 10:
                plt.figure(figsize=(8, 5))
                plt.plot(real_spec, label="Real Spectrum", linewidth=2)
                plt.plot(best_fake, label="Best GAN Spectrum", linestyle="--")
                plt.plot(new_spec, label="Final Augmented Spectrum", linewidth=2)
                for wl in wl_to_plot:
                    plt.axvline(x=int(wl), color='red', linestyle=':', linewidth=1)
                plt.title(f"{class_name} - SAM={best_sam:.4f}")
                plt.xlabel("Band Index")
                plt.ylabel("Reflectance")
                plt.legend()
                plt.tight_layout()
                if plot_dir is not None:
                    plt.savefig(plot_dir / f"{class_name}_{plot_count}.png")
                plt.close()
                plot_count += 1

    return augmented_cube

def generate_multiple_augmented(
    dataset_root,
    input_cube_paths,
    wl_max10,
    wl_max20,
    output_dir,
    base_extrudes=50,
    extra_per_class=None,
    wl_noise_index=0,
    alpha_noise=1.0,
    device="cuda"
):
    if extra_per_class is None:
        extra_per_class = {}

    dataset = SpectralPixelDataset(dataset_root)
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    cube_counter = 0
    for cube_path in input_cube_paths:
        cube_prefix = Path(cube_path).stem.split("_")[0]
        spectra_class = get_spectra_class(dataset, cube_prefix)
        n_extrudes = base_extrudes + extra_per_class.get(cube_prefix, 0)

        netG_path = f"./results/{cube_prefix}/netG_best.pth"
        netG = torch.load(netG_path)
        netG.to(device)
        netG.eval()

        for n in range(n_extrudes):
            plot_folder = output_dir / f"{cube_prefix}_cube{cube_counter}_plots_{n}"
            plot_folder.mkdir(parents=True, exist_ok=True)

            hdr_img = envi.open(cube_path)
            cube = np.array(hdr_img.load(), dtype=np.float32)

            aug_cube = generate_augmented_cube(
                cube,
                cube_prefix,
                netG,
                wl_max10,
                wl_max20,
                spectra_class=spectra_class,
                wl_noise_index=wl_noise_index,
                alpha_noise=alpha_noise,
                device=device,
                save_plots=True,
                plot_dir=plot_folder
            )

            save_path = output_dir / f"{cube_prefix}_cube{cube_counter}_aug_{n}.hdr"
            envi.save_image(str(save_path), aug_cube, dtype=np.float32, force=True, interleave="bsq")

        print(f"{n_extrudes} extrusions générées pour le cube {cube_path}")
        cube_counter += 1

from pathlib import Path

# Dossier contenant tous les cubes HDR
dataset_root = "/chemin/vers/cubes"  

# Dossier de sortie pour les cubes augmentés
output_dir = "/chemin/vers/output_augmented"  

# Dictionnaires des longueurs d'onde sélectionnées par classe
wl_max10 = {
    "A1": [2,5,7], 
    "B1": [1,3,8],
    # ajouter toutes les classes
}
wl_max20 = {
    "A1": [0,1,2,3,4,5,6,7,8,9],
    "B1": [0,1,2,3,4,5,6,7,8,9],
    # ajouter toutes les classes
}

# Nombre d'extrusions supplémentaires par classe si besoin
extra_per_class = {
    "A1": 20,  # 50 + 20 = 70 extrusions pour A1
    "B1": 10,
    # les autres classes par défaut = 50
}

# Récupérer tous les fichiers HDR dans le dossier dataset_root
dataset_root_path = Path(dataset_root)
input_cube_paths = list(dataset_root_path.rglob("*.hdr"))

# Appel de la fonction de génération multiple
generate_multiple_augmented(
    dataset_root=dataset_root,
    input_cube_paths=input_cube_paths,
    wl_max10=wl_max10,
    wl_max20=wl_max20,
    output_dir=output_dir,
    base_extrudes=50,
    extra_per_class=extra_per_class,
    alpha_noise=1.0,  # facteur de bruit
    device="cuda"      # ou "cpu"
)


import numpy as np

def augment_with_class_noise(real_spec, spectra_class, alpha=1.0):
    sigma_per_pixel = np.std(spectra_class, axis=0)
    mean_class = np.mean(spectra_class, axis=0)
    mean_class_safe = np.where(mean_class > 0, mean_class, 1.0)
    relative_noise_profile = sigma_per_pixel / mean_class_safe
    raw_noise = np.random.randn(len(real_spec))
    scaled_noise = raw_noise * relative_noise_profile * real_spec * alpha
    scaled_noise = scaled_noise - np.mean(scaled_noise)
    S_aug = np.clip(real_spec + scaled_noise, 0, 1)
    return S_aug

import numpy as np

def augment_with_class_noise_relative(real_spec, spectra_class, alpha=1.0):
    wl_index = np.random.randint(0, spectra_class.shape[1])
    sigma_wl = np.std(spectra_class[:, wl_index])
    mean_wl = np.mean(spectra_class[:, wl_index])
    relative_noise = sigma_wl / mean_wl if mean_wl > 0 else 0
    raw_noise = np.random.randn(len(real_spec)) * relative_noise * real_spec * alpha
    raw_noise = raw_noise - np.mean(raw_noise)
    S_aug = np.clip(real_spec + raw_noise, 0, 1)
    return S_aug