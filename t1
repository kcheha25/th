import numpy as np
import matplotlib.pyplot as plt
import sif_parser  
from sif_parser.utils import extract_calibration

# ---------------------------
# Charger les données
# ---------------------------
file_path = "chemin/vers/fichier.sif" 
data, info = sif_parser.np_open(file_path)

# data.shape == (22500, 1, 2048)
# Supprimer la dimension singleton
data = data[:, 0, :]
print("Shape after flattening:", data.shape)  # (22500, 2048)

# ---------------------------
# Reformater le cube
# ---------------------------
height, width = 150, 150
datacube = data.reshape(height, width, -1)
print("Datacube shape:", datacube.shape)  # (150, 150, 2048)

# ---------------------------
# Extraire la calibration
# ---------------------------
wavelengths = extract_calibration(info)
if wavelengths is None:
    raise ValueError("Aucune calibration trouvée dans le fichier SIF")

# ---------------------------
# Trouver l'indice correspondant à 266 nm
# ---------------------------
target_wl = 266.0
idx = np.argmin(np.abs(wavelengths - target_wl))
print(f"Indice correspondant à {target_wl} nm : {idx}, longueur d'onde exacte : {wavelengths[idx]:.2f} nm")

# ---------------------------
# Extraire la cartographie à 266 nm
# ---------------------------
image_266 = datacube[:, :, idx]

# ---------------------------
# Afficher la cartographie
# ---------------------------
plt.figure(figsize=(6, 5))
plt.imshow(image_266, cmap='inferno')
plt.colorbar(label='Intensité')
plt.title(f'Cartographie à {wavelengths[idx]:.2f} nm')
plt.xlabel('Pixel X')
plt.ylabel('Pixel Y')
plt.show()
##########################################################################
class F2D:
    def __init__(self, data):
        self.data = np.array(data, dtype=float)
        self.H, self.W = self.data.shape

    def __call__(self, y, x):
        return self.data[y, x]

    def set(self, y, x, v):
        self.data[y, x] = v

    def copy(self):
        return F2D(self.data.copy())
ImD = F2D(image_266)

def cross_correlation(ImD, iLine, iShift, nMargin):
    W = ImD.W
    n = W - 2 * nMargin
    if n < 1:
        return 0.0

    IMoyCur = 0.0
    IMoyUD = 0.0

    for i in range(nMargin, W - nMargin):
        IMoyCur += ImD(iLine, i + iShift)
        IMoyUD += ImD(iLine - 1, i) + ImD(iLine + 1, i)

    IMoyCur /= n
    IMoyUD /= n

    SumNum = SumCur = SumUD = 0.0

    for i in range(nMargin, W - nMargin):
        xCur = ImD(iLine, i + iShift) - IMoyCur
        xUD = (ImD(iLine - 1, i) + ImD(iLine + 1, i)) - IMoyUD
        SumNum += xCur * xUD
        SumCur += xCur * xCur
        SumUD += xUD * xUD

    return SumNum / np.sqrt(1e-30 + SumCur * SumUD)
def find_line_offsets_iter(ImD, nMargin):
    W, H = ImD.W, ImD.H
    ImDCor = ImD.copy()
    LineOff = np.zeros(H, dtype=int)
    sumOffset = 0

    for j in range(1, H - 1):
        CCk = []

        for k in range(-nMargin, nMargin + 1):
            CCk.append(cross_correlation(ImD, j, k, nMargin))

        CCk = np.array(CCk)
        CCMax = CCk.max()
        kMax = np.where(CCk == CCMax)[0][0] - nMargin

        if CCMax > 0.2:
            LineOff[j] = kMax
            sumOffset += abs(kMax)

            for i in range(W):
                src = (i + kMax) % W
                ImDCor.set(j, i, ImD(j, src))

    return ImDCor, LineOff, sumOffset
def find_line_offsets(ImD, maxIter, nMargin):
    H = ImD.H
    LineOffsets = np.zeros(H, dtype=int)
    ImDCur = ImD.copy()

    for _ in range(maxIter):
        ImDCor, curOff, nUpdate = find_line_offsets_iter(ImDCur, nMargin)
        LineOffsets += curOff
        ImDCur = ImDCor
        if nUpdate == 0:
            break

    return LineOffsets
nMargin = 5
maxIter = 10

LineOffsets = find_line_offsets(ImD, maxIter, nMargin)
def correct_datacube(datacube, LineOffsets):
    H, W, Z = datacube.shape
    corrected = datacube.copy()

    for j in range(H):
        kMax = LineOffsets[j]
        for i in range(W):
            src = (i + kMax) % W
            corrected[j, i, :] = datacube[j, src, :]

    return corrected

datacube_corrected = correct_datacube(datacube, LineOffsets)

image_266_cor = datacube_corrected[:, :, idx]

plt.figure(figsize=(12, 5))

plt.subplot(1, 2, 1)
plt.imshow(image_266, cmap='inferno')
plt.title("Avant correction")
plt.colorbar()

plt.subplot(1, 2, 2)
plt.imshow(image_266_cor, cmap='inferno')
plt.title("Après correction")
plt.colorbar()

plt.show()


##################3
import numpy as np
import matplotlib.pyplot as plt
import sif_parser
from sif_parser.utils import extract_calibration
from numba import njit, prange

# ---------------------------
# Charger les données
# ---------------------------
file_path = "chemin/vers/fichier.sif"
data, info = sif_parser.np_open(file_path)
data = data[:, 0, :]  # Supprimer dimension singleton

height, width = 150, 150
datacube = data.reshape(height, width, -1)  # Cube H x W x Z

wavelengths = extract_calibration(info)
if wavelengths is None:
    raise ValueError("Aucune calibration trouvée dans le fichier SIF")

target_wl = 266.0
idx = np.argmin(np.abs(wavelengths - target_wl))
image_266 = datacube[:, :, idx]

plt.figure(figsize=(6, 5))
plt.imshow(image_266, cmap='inferno')
plt.colorbar(label='Intensité')
plt.title(f'Cartographie à {wavelengths[idx]:.2f} nm')
plt.show()


@njit
def cross_correlation_numba(ImD, iLine, iShift, nMargin):
    W = ImD.shape[1]
    n = W - 2 * nMargin
    if n < 1:
        return 0.0

    IMoyCur = 0.0
    IMoyUD = 0.0
    for i in range(nMargin, W - nMargin):
        IMoyCur += ImD[iLine, i + iShift]
        IMoyUD += ImD[iLine - 1, i] + ImD[iLine + 1, i]

    IMoyCur /= n
    IMoyUD /= n

    SumNum = 0.0
    SumCur = 0.0
    SumUD = 0.0
    for i in range(nMargin, W - nMargin):
        xCur = ImD[iLine, i + iShift] - IMoyCur
        xUD = (ImD[iLine - 1, i] + ImD[iLine + 1, i]) - IMoyUD
        SumNum += xCur * xUD
        SumCur += xCur * xCur
        SumUD += xUD * xUD

    return SumNum / np.sqrt(1e-30 + SumCur * SumUD)


@njit(parallel=True)
def find_line_offsets_iter_numba(ImD, nMargin):
    H, W = ImD.shape
    LineOff = np.zeros(H, dtype=np.int32)
    ImDCor = ImD.copy()

    for j in prange(1, H - 1):
        CCk = np.empty(2 * nMargin + 1, dtype=np.float64)
        for k in range(-nMargin, nMargin + 1):
            CCk[k + nMargin] = cross_correlation_numba(ImD, j, k, nMargin)

        CCMax = CCk.max()
        kMax = np.argmax(CCk) - nMargin

        if CCMax > 0.2:
            LineOff[j] = kMax
            for i in range(W):
                src = (i + kMax) % W
                ImDCor[j, i] = ImD[j, src]

    return ImDCor, LineOff

def find_line_offsets(ImD, maxIter, nMargin):
    LineOffsets = np.zeros(ImD.shape[0], dtype=np.int32)
    ImDCur = ImD.copy()
    for _ in range(maxIter):
        ImDCor, curOff = find_line_offsets_iter_numba(ImDCur, nMargin)
        LineOffsets += curOff
        if np.all(curOff == 0):
            break
        ImDCur = ImDCor
    return LineOffsets

@njit(parallel=True)
def correct_datacube_numba(datacube, LineOffsets):
    H, W, Z = datacube.shape
    corrected = np.empty_like(datacube)
    for j in prange(H):
        kMax = LineOffsets[j]
        for i in range(W):
            src = (i + kMax) % W
            corrected[j, i, :] = datacube[j, src, :]
    return corrected

nMargin = 3
maxIter = 10

LineOffsets = find_line_offsets(image_266, maxIter, nMargin)
datacube_corrected = correct_datacube_numba(datacube, LineOffsets)

image_266_cor = datacube_corrected[:, :, idx]

plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
plt.imshow(image_266, cmap='inferno')
plt.title("Avant correction")
plt.colorbar()

plt.subplot(1, 2, 2)
plt.imshow(image_266_cor, cmap='inferno')
plt.title("Après correction")
plt.colorbar()
plt.show()


def calc_average_spectrum(datacube):
    """
    datacube : (H, W, Z)
    """
    mean_spectrum = datacube.mean(axis=(0, 1))
    max_intensity = mean_spectrum.max()
    return mean_spectrum, 

import tkinter as tk
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

def show_mean_spectrum_tk(datacube, wavelengths):
    mean_spectrum, max_intensity = calc_average_spectrum(datacube)

    root = tk.Tk()
    root.title("Spectre moyen LIBS")

    fig, ax = plt.subplots(figsize=(7, 4))
    ax.plot(wavelengths, mean_spectrum, color="blue")
    ax.set_xlabel("Longueur d'onde (nm)")
    ax.set_ylabel("Intensité moyenne")
    ax.set_title("Spectre moyen hyperspectral")
    ax.grid(True)

    # affichage de l'intensité max
    ax.text(
        0.02, 0.95,
        f"Max = {max_intensity:.2f}",
        transform=ax.transAxes,
        verticalalignment='top'
    )

    canvas = FigureCanvasTkAgg(fig, master=root)
    canvas.draw()
    canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

    root.mainloop()

show_mean_spectrum_tk(datacube, wavelengths)
mean_before, _ = calc_average_spectrum(datacube)
mean_after, _ = calc_average_spectrum(datacube_corrected)

plt.figure()
plt.plot(wavelengths, mean_before, label="Avant")
plt.plot(wavelengths, mean_after, label="Après")
plt.legend()
plt.title("Comparaison spectre moyen")
plt.show()


def calc_average_spectrum(datacube):
    mean_spectrum = datacube.mean(axis=(0, 1))
    return mean_spectrum

def crop_datacube_spectral(datacube, wavelengths, wl_min, wl_max):
    mask = (wavelengths >= wl_min) & (wavelengths <= wl_max)
    cropped_cube = datacube[:, :, mask]
    cropped_wl = wavelengths[mask]
    return cropped_cube, cropped_wl

import tkinter as tk
from tkinter import messagebox
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
import numpy as np
import matplotlib.pyplot as plt


datacube_cropped = None
wavelengths_cropped = None

def show_mean_spectrum_tk(datacube, wavelengths):
    global datacube_cropped, wavelengths_cropped

    mean_spectrum = calc_average_spectrum(datacube)

    root = tk.Tk()
    root.title("Spectre moyen LIBS – Zoom & Crop")

    fig, ax = plt.subplots(figsize=(8, 4))
    ax.plot(wavelengths, mean_spectrum, color="blue")
    ax.set_xlabel("Longueur d'onde (nm)")
    ax.set_ylabel("Intensité moyenne")
    ax.grid(True)

    canvas = FigureCanvasTkAgg(fig, master=root)
    canvas.draw()
    canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

    frame = tk.Frame(root)
    frame.pack(pady=5)

    tk.Label(frame, text="λ min").grid(row=0, column=0)
    entry_min = tk.Entry(frame, width=8)
    entry_min.grid(row=0, column=1)
    entry_min.insert(0, f"{wavelengths.min():.1f}")

    tk.Label(frame, text="λ max").grid(row=0, column=2)
    entry_max = tk.Entry(frame, width=8)
    entry_max.grid(row=0, column=3)
    entry_max.insert(0, f"{wavelengths.max():.1f}")

    def apply_crop():
        global datacube_cropped, wavelengths_cropped

        wl_min = float(entry_min.get())
        wl_max = float(entry_max.get())

        datacube_cropped, wavelengths_cropped = crop_datacube_spectral(
            datacube, wavelengths, wl_min, wl_max
        )

        ax.clear()
        ax.plot(wavelengths_cropped,
                datacube_cropped.mean(axis=(0, 1)),
                color="red")
        ax.set_xlim(wl_min, wl_max)
        ax.set_title("Spectre moyen coupé")
        ax.grid(True)
        canvas.draw()

    tk.Button(frame, text="Appliquer crop", command=apply_crop)\
        .grid(row=1, column=0, columnspan=4, pady=5)

    root.mainloop()

datacube_cropped.shape
# (150, 150, Z_crop)

wavelengths_cropped.shape
# (Z_crop,)


show_mean_spectrum_tk(datacube_corrected, wavelengths)
